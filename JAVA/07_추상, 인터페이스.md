## 추상, 인터페이스

### 1. 추상클래스

미완성 설계도. -  `abstract` class 클래스명

- 완성된 제품을 만들 수 없듯이 **추상클래스로 인스턴스를 생성할 수 없다.**
  -> 상속을 통해서 자손 클래스에 의해 완성
- 새로운 클래스를 정의할 때 아무것도 없는 것부터 시작하는 것보다 완전하지 못해도 어느정도 틀을 갖춘 상태에서 시작하는 것이 낫기에 사용
- `abstract`으로 추상클래스임을 확인하고 추상메서드가 있을 것이라 생각해 상속이 필요함을 쉽게 알 수 있음



### 2. 추상 메서드

- 미완성 상태로 남겨두는 이유?

  > 자식클래스에 따라 기능 구현이 다르기 때문에 부모 클래스에서는 선언만(미완성 상태)하고 주석을 통해 어떤 기능을 수행할지 알려주고, 실제 내용은 자식클래스에서 구현하도록 비워두는 것

- 자식클래스는 오버라이딩을 통해 부모(추상)클래스의 추상메소드를 모두 구현함

- 부모클래스에서 상속받은 추상메서드 중 하나라도 구현안하면, 자식클래스 역시 추상 클래스로 지정해줘야 함



### 3. 인터페이스

일종의 추상클래스. -  `interface` 인터페이스명

- 추상메소드를 갖지만 추상클래스보다 추상화 정도가 높아 body를 가진 일반메소드나 멤버변수를 가질 수 없음
- 오직 추상메서드와 상수만 멤버로 가질 수 있음
- 멤버변수는 무조건 `public static final` (생략은 가능)



- 인터페이스 이해

![image-20200908003300196](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200908003300196.png)

왼쪽은 A에서 B를 바로 호출하여 직접 연결되어있어 둘 중 하나만 변경되더라도 영향을 바로 미치게 된다. 하지만 오른쪽은 **중간에 인터페이스를 두어 간접적인 관계**로 내용이 변경되도 I와 B간 변경만 하고 A와 B의 관계에는 아무런 변화가 없다. 

이때 C라는 객체를 추가하려고 한다면 I를 상속받아 구현부만 작성해주면 A가 호출했을 때 인스턴스만 변경하여 생성하면 똑같이 사용이 가능하다. 

즉, 인터페이스로 인해 반환형과 매개변수를 알기에 A와 B 클래스의 작업이 동시에 가능해져서 개발시간이 단축될 수 있다. 



### 4. 인터페이스의 상속

> 다중상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있음
- 여러개의 인터페이스로부터 상속 받을 수 있음

``` java
interface Movable{
 //지정된 위치(x,y)로 이동하는 기능의 메서드
 void move(int x, int y);
}

interface Attackable{
 //지정된 대상을 공격하는 기능의 메서드
 void attack(Unit u);
}

interface Fightable extends Movable, Attackable { }
```

Fightable 자체에는 정의된 멤버가 하나도 없지만 부모인터페이스로부터 상속받은 추상메소드인 move(int x, int y)와 attack(Unit u)을 멤버로 가지게 된다.



### 5. 인터페이스의 구현

- 인터페이스도 추상클래스처럼 인스턴스를 생성할 수 없음 
- 추상클래스가 **상속을 통해** 추상메서드를 완성하듯이 (`extends`사용)
  -> 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 하는데 상속과 다르지 않음 (`implements`사용)



### 6. 인터페이스를 이용한 다형성

