# DP (다이나믹 프로그래밍)

작은 문제들을 풀면, 비슷하고 같은 문제를 반복해서 풀지만,
**매번 다시 계산하지 않고, 리스트나 다른 곳에 값을 저장해두었다가** 이 값들을 다시 사용하는 기법

## 특징

- 처음에 x로 정수를 입력받고 result변수를 만들어 []리스트에 0을 x만큼 추가하여 생성한다.
- 리스트를 만들어 값을 매번 저장하여 속도향상에 도움이 된다. (재귀함수를 매번 호출하면 시간복잡도↑)
  <br/>
- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산x
- 탑다운과 보텀업으로 구성
- 배열이나 리스트 이용하여 표현할 것
- 피보나치...등

## 조건

- 최적 부분 구조(optimal substructure)
- 중복되는 부분 문제(overlapping subproblem)

## 구현 방식

1. 탑다운 (메모이제이션 memization) - 하향식

- 재귀함수
- 시간 복잡도 O(N)
  > 메모이제이션 : 한 번 계산한 결과를 메모리 공간에 메모하는 기법
  >
  > - 같은 문제를 다시 호출하면 메모했던 결과를 그래도 가져옴
  > - 값을 기록해놓은 것 : cashing

2. 보텀업 - 상향식 :star:

- 반복문 사용
- 결과 저장용 리스트: DP 테이블

### DP vs. 분할 정복

- 모두 최적 부분 구조를 가질 때 사용함
  (큰 문제를 작은 문제로 나누고 작은 문제의 답을 모아 큰 문제를 해결하는 상황)
- 가장 큰 차이점은 `부분 문제의 중복`
  - DP는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됨
  - 분할 정복은 동일한 부분 문제가 반복적으로 계산되지 않음 (퀵 정렬)

## 풀이 방법

- 다이다믹 프로그래밍 유형임을 파악할 것
- 완전탐색, 그리디, 구현 등의 아이디어로 문제 해결이 가능한지 검토 but 다른 풀이가 떠오르지 않으면 DP 사용해볼 것
- 일단 재귀함수로 비효율적인 완전탐색 프로그램을 작성한 뒤 탑다운 방식으로 사용할 수 있는지 확인할 것(탑다운으로 코드 개선)
- 일반 코테에서는 기본 유형의 DP 문제를 출제하는 경우가 많아 여러번 반복적인 학습으로 익숙해질 것!
